
<html>
  <head>
    <script type="text/javascript" src="https://cindyjs.org/dist/snapshot/Cindy.js"></script>
    <script type="text/javascript" src="https://cindyjs.org/dist/snapshot/CindyGL.js"></script>
    <title>Mini Paint</title>
    <style type="text/css">
        body {
            margin: 0px;
            padding: 0px;
        }

        #CSCanvas {
            width: 100vw; height: 100vh;
        }
    </style>
  </head>

  <body>
    <div id="CSCanvas"></div>

    <script id="csinit" type="text/x-cindyscript">
      //wird einmal am Anfang ausgeführt

      use8bittextures();
      //inititalisation of resolution and screenbounds
      res=2048;
      lb=2*(screenbounds()_4).xy;
      rb=2*(screenbounds()_3).xy;
      lbpal=(screenbounds()_3).xy-(0.65,0);
      rbpal=(screenbounds()_3).xy;

      // inititalisation of images
      createimage("basis",res,res);
      createimage("canvas",res,res);
      createimage("layer",res,res);
      createimage("output",res,res);

      createimage("test",res,res);
      colorplot("test",[1,1,1,1]);

      // userinterface
      functions=["⥅","↺","⇹","↴"];
      mode="draw";
      stiftstaerke=6/500;
      stiftfarbe=[0.8,0.8,1];
      createimage("palette",128,800);
      colorplot("palette",[0.3,0.3,0.3]);
      farbpalette=[[0.8,0.8,0.5],[0.8,0.8,1],[0.8,0.9,1],[0.9,0.7,0.6],[0.4,0.9,0.9],[0.4,0.5,0.7],[0.2,0.3,0.6],[0.8,0.4,0.3],[0.9,1,0.7]];
      staerkepalette=[2,4,6,8,10,12,14,16]*1/500;
      selectc=false;
      selects=false;
      selectf=false;
      preview=false;
      psnapcolor=1/255*[152,251,152];
      psnapsize=8;
      constructioncolor=.9*[1,1,1];

      // set of saved transformations
      savedtrafos =[];
      // standard matrices and values
      identity = [[1,0,0],[0,1,0],[0,0,1]];
      inittrafo=[[0,0,0],[0,0,0],[0,0,0]];
      epsilon=0.01;


      // set of saved transformations sampled by transformation type
      pastrefl=[];
      pasttrans=[];
      pastrot=[];
      pastgtrans=[];
      lasttrafo=[];

      k=1;

      lastorbit=0;
      nsteps=0;
      firstpaint=true;
      istap=false;

      // reset values when deleting drawing
      reset():=(
        pastrefl=[];
        pasttrans=[];
        pastrot=[];
        pastgtrans=[];
        lasttrafo=[];

        selectf=false;
        lastorbit=0;
        nsteps=0;
        savedtrafos =[];
        previewtrafo=0;
        firstpaint=true;
        mode="draw";
        istap=false;
      );

      // apply transformation 'T' on point 'p'
      applyTrafo(T,p):=(
        T=T/T_3_3;
        T*[p_1,p_2,1];
      );
      // add transformation 'T' to the set of saved transformations
      addTrafo(T) := (
        savedtrafos = savedtrafos :> T;
      );

      // implementation of A(x)-init, matrix product of relation depending on variable end point x
      matrixA(x):=(
        t1=map(p0,x,p0,p0+(0.2,0));
        t1;
      );
      // implementation of polynomial relation depending on variable end point x
      polynomial(x):=(
        A=matrixA(x);
        A=A/(A_3_3);
        p=[6,7,1];

        f=[row(A,1)*p-p_1,row(A,2)*p-p_2];
      );

      // implementation of the jacobian matrix of the polynomial relation depending on variable end point x
      jacobiPolynomial(x):=(
        y=polynomial(x);
        h0=epsilon;
        Df=[[0,0],[0,0]];
        forall(1..2,k,
          h=max(1,abs(x_k))*h0;
          forall(1..2,i,
            Df_i_k=(polynomial(x+h*column(identity,k))_i-y_i)/h;
          );
        );
      Df;
      );

      // implementation of Newton's method with inital point 'x' and number of Newton steps 'm'
      newton(x,m):=(
        repeat(m,
          x=x-inverse(jacobiPolynomial([x_1,x_2,1]))*polynomial([x_1,x_2,1]);
        );
        x
      );

      // implementation of the iterative orbit calculation Algorithm 3
      // under a semigroup generated by 'currenttrafos',
      // of point 'ptx', with a maximal amount of 'limit' orbit points,
      // all orbit points inside an radius constrained by 'region',
      // number of iterations 'nrep'

      // returning a list of 'orbit' points,
      // a list of predecending points 'predpoints' to each orbit point
      // and a list of predecending transformations 'predtrafos' that maps the predecending point to the orbit point

      orbit(currenttrafos,ptx,limit,region,nrep):=(
        discrete=true;
        orbitcolortemp=[[1,0,0]];
        orbitcolor=[];
        temporbit=[ptx];orbit=[];predpointstemp=[ptx];predtrafostemp=[inittrafo];predpoints=[];predtrafos=[];
        points=[ptx];
        repeat(nrep,
          if(length(temporbit)<limit & discrete,
            ptsimage=[];
            forall(1..length(points),pt,
              forall(1..length(currenttrafos),st,
                unique=true;
                pto=applyTrafo(inverse(currenttrafos_st),points_pt);
                pto=[pto_1,pto_2]/pto_3;
                forall(temporbit,o,
                  if(|o,pto|<.01,unique=false)
                );
                if(unique & |pto,[0,0]|<region,
                  temporbit=temporbit:>pto;
                  ptsimage=ptsimage:>pto;
                  predpointstemp=predpointstemp:>points_pt;
                  predtrafostemp=predtrafostemp:>st;
                  orbitcolortemp=orbitcolortemp:>[1/255*[181, 224, 255],1/255*[140, 181, 255],1/255*[84, 150, 255],1/255*[0, 9, 235],1/255*[0, 0, 184],1/255*[0, 31, 143]]_#;
                );
              );
            )
          ,discrete=false);
          if(ptsimage!=[],points=ptsimage,points=points);
        );
        if(!discrete,temporbit=[]);
        forall(1..length(temporbit),tpo,
          if(|temporbit_tpo,[0,0]|<region/2,
            orbit=orbit:>temporbit_tpo;
            predtrafos=predtrafos:>predtrafostemp_tpo;
            predpoints=predpoints:>predpointstemp_tpo;
            orbitcolor=orbitcolor:>orbitcolortemp_tpo;
          );
        );
        [orbit,predpoints,predtrafos];
      );

      // implementation of the path determination Algorithm 5
      // 'from' a point in the orbit to the sart point of the orbit 'to'
      // orbit, predpoints, predtrafos calculated by the previous function

      // returning a string of the 'path' between 'from' and 'to', e.g 't1*t2*t1'

      path(from,to,orbit,predpoints,predtrafos):=(
        path="";
        path2=[];
        error=false;
        repeat(20,
          if(from!=to & !error,
            index=0;
            forall(1..length(orbit),o,
              if(orbit_o==from,index=o)
            );
            if(index!=0,
              path="t"+text(predtrafos_index)+"*"+path;
              pathViz=predpoints_index<:path2;
              from=predpoints_index,
              path="";
              error=true;
            );
          );
        );
      path
      );

      // implementation of orbit collision detection Algorithm 4 and relation formulation
      // detect a collistion of two orbit points in the orbit of 'p0' under the semigroup generated by 'currenttrafos' that is calculated by 'nrep' iterations
      // with the possibility to require a minimal amount of candidates 'thres' in order for a relation to be formulated

      // returning 'path' which is a closed loop of the two paths from 'p0' to each collision point

      polynomGen(p0,currenttrafos,nrep,thres):=(
        region=30;limitorbit=1000;
        [orbit,predpoints,predtrafos]=orbit(currenttrafos,p0,limitorbit,region,nrep);
        lowerlimit=0.000001;
        testpoint1=[1000,1000];
        testpoint2=[-1000,-1000];
        neighbors=0;
        candidates=0;
        upperlimit=0.02;
        // collision detection
        forall(orbit,o1,
          forall(orbit,o2,
            if(lowerlimit<|o1,o2| & |o1,o2|<upperlimit,testpoint1=o2;testpoint2=o1;upperlimit=0);//;neighbors=1);
            if(lowerlimit<|o1,o2| & |o1,o2|<0.02,candidates=candidates+1);
          )
        );
        // relation formulation
        if(candidates>=thres,
          path1=path(testpoint1,p0,orbit,predpoints,predtrafos);
          pathViz1=pathViz;
          path2=path(testpoint2,p0,orbit,predpoints,predtrafos);
          pathViz2=pathViz;
          path2list=tokenize(path2,"*");
          path1list=tokenize(path1,"*");
          if(path2list-path1list==[],
            path="",
            path2inv="";
            forall(1..(length(path2list)-1),pl,
              path2inv="inverse("+path2list_pl+")*"+path2inv;
            );
            path=path2inv+path1;
            path=substring(path,0,length(path)-1);
          ),
          path="";
        );
        path
      );

      // calculates the distance of a pixel 'hash' from a segment from 'p0' to 'p1'
      distance(p0,p1,hash):=(
        dir=p1-p0;
        diro=[dir.y,-dir.x];
        dir2=p0-p1;
        w1=hash-p0;
        w2=hash-p1;
        x=meet(join(p0,p1),join(hash,hash+diro));
        x=[x_1,x_2]/x_3;
        if(w1*dir>0 & w2*dir2>0,dist=|hash-x|,dist=100);
      );

      framecount = 0;
      playanimation();
      pathtest=[];

    </script>


    <script id="csdraw" type="text/x-cindyscript">
      //wird ausgeführt wenn die Szene gezeichnet wird
      framecount = framecount + 1;
      if(framecount > 1000,
          pauseanimation();
      );


      drawimage(lb,rb,"basis");
      trafos=savedtrafos;
      if(preview,trafos=trafos:>previewtrafo);
      if(length(trafos)==0,
        trafos = [[[1,0,0],[0,1,0],[0,0,1]]];
      );
      N=length(trafos);

      // implementation of Algorithm for repeating a pattern, Algorithm 1
      colorplot(lb,rb,"layer",
        basis=imagergba(lb,rb,"canvas",#, interpolate->false, interpolate->false);
        forall(1..N,i,
          tc = applyTrafo(trafos_i,#);
          tcp = [tc_1,tc_2]/tc_3;
          repeat=imagergba(lb,rb,"layer",tcp,repeat->false, interpolate->true)*min(1,3*(rb.x-max(apply(tcp, c, |c|))));
          if(repeat.a>basis.a,
            basis=repeat;
          );
        );
        if(preview,
          basis = basis*.9;
        );
        basis;
      );
      colorplot(lb,rb, "output",imagergb(lb,rb,"layer",#));
      drawimage(lb,rb, "output");

      // User interface
      drawimage(lbpal,rbpal,"palette");

      drawtext((lbpal.x+0.5*0.065,0.9),"First paint..",color->.7*[1,1,1],size->16);
      forall(1..9,i,
        drawcircle(((lbpal.x+i*0.065),0.7),staerkepalette_i,color->[0.6,0.6,0.6],size->2);
        fillcircle(((lbpal.x+i*0.065),0.7),staerkepalette_i,color->stiftfarbe);
      );
      forall(1..9,i,
        drawcircle(((lbpal.x+i*0.065),0.8),14/500,color->[0.6,0.6,0.6],size->2);
        fillcircle(((lbpal.x+i*0.065),0.8),14/500,color->farbpalette_i);
      );
      drawtext([lbpal.x+9*0.065,0.5],"⎌",size->26,color->[0.6,0.6,0.6]);
      drawtext([lbpal.x+8*0.065,0.2],"🗑️",size->28);
      //drawtext(lbpal+(0.03,0.05),"by Elena Mille",color->.6*[1,1,1]);

      if(selectc,drawcircle(((lbpal.x+ic*0.065),0.8),14/500,color->[1,1,1],size->4));
      if(selects,drawcircle(((lbpal.x+is*0.065),0.7),staerkepalette_is,color->[1,1,1],size->4));

      drawtext((lbpal.x+0.5*0.065,0.6),"..then choose a transformation.",color->.7*[1,1,1],size->16);
      forall(0..(length(functions)-1),i,
        drawtext(size->26, align->"mid",(lbpal.x+(i*2+1)*0.06,0.5),functions_(i+1), color ->[0.6,0.6,0.6]);
        );
      if(selectf,drawtext(size->26, align->"mid",(lbpal.x+(ifu*2+1)*0.06,0.5),functions_(ifu+1), color ->[1,1,1]));
      drawtext((lbpal.x+0.5*0.065,0.4),"Aaand repeat!",color->.7*[1,1,1],size->16);

      drawtext((lbpal.x-0.04,0),
        "
        Look out for the green dots!
        They help you paint the
        crystallographic groups.",
        color ->[0.6,0.6,0.6],size->14);
      drawtext((lbpal.x+0.04,-0.5),tstr,color->[1,1,1],size->9);

      //Translation
      if(mode=="⥅",
        if(step==0,
          p0=mouse();
          if(p0.x<lbpal.x,
            draw(p0, color->[0.9,0.9,0.9],size->5);
            drawtext(mouse()-(0,0.05),"Tap and drag",color->1*[1,1,1]);
          );

          psnap=[p0];
          pairs=[];
          thres=1;
          tstr="";
        );
        if(step==1,
          draw(p0, color->[0.9,0.9,0.9],size->5);
          p1=mouse();
          drawtext(mouse()-(0,0.05),"Tap to confirm",color->1*[1,1,1]);
          c=length(savedtrafos);
          Tnew=map(p0,p1);Tnew=Tnew/Tnew_3_3;
          currenttrafos=savedtrafos:>Tnew;
          nrep=[10,5,3]_(length(savedtrafos));

          //Generation of poylnomial relation
          if(polynomGen(p0,currenttrafos,nrep,thres)!="",tstr=polynomGen(p0,currenttrafos,nrep,thres),tstr=tstr);
          oldtrafos="";
          forall(1..c,st,oldtrafos=oldtrafos+"t"+text(st)+"="+text(savedtrafos_st)+";");

          // setting A(x) to be the matrix product of the current relation
          parse("matrixA(x):=("+oldtrafos+"t"+text(length(currenttrafos))+"=map(p0,x);"+tstr+")");
          go=true;

          // Solving by Newton
          nr = newton(mouse(),3);

          // assuring disjoint open sets around snap points
          forall(psnap,ps,
            if(|nr,ps|<.04,go=false);
          );

          // check if newton's result is close enough to zero, and if yes add it to the set of snap
          if(go & |polynomial([nr_1,nr_2,1])|<.009,
            psnap=psnap:>nr;
          );
          forall(psnap,ps,
            if(|ps-p1|<0.1,
              draw(ps,color->psnapcolor,noborder->true,size->psnapsize);
              // snapping to snap point 'ps' if 'p1' is element of the open set around 'ps' with an radius of 0.03
              if(|p1-ps|<0.03,
                p1=ps;
              )
            );
          );

          draw(p0,p1, arrow->true, alpha->.8, size->4, color->constructioncolor);
          previewtrafo=map(p1,p0);
          preview=true;
        );

        if(step==2,
          preview=false;
          Tnew=map(p1,p0);
          Tnew=Tnew/Tnew_3_3;

          addTrafo(Tnew);
          pasttrans=pasttrans:>Tnew;
          lasttrafo=lasttrafo:>"Translation";

          colorplot(lb,rb, "layer",[0,0,0,0]);
          step=-1;
        );
      );

      if(mode=="↺",
        if(step==0,
          p0=mouse();
          if(p0.x<lbpal.x,
            if(pastrot!=[],
              draw(p0, color->.9*[1,1,1],size->5);
              forall(1..length(pastrot),rot, draw(pastrot_rot,color->.8*[1,1,1],noborder->true));
              );
              draw(p0, color->.9*[1,1,1],size->5);
              drawtext(p0-(0,0.05),"Tap for rotation centre and drag",color->[1,1,1]);
            );

          psnap=[];
          pairs=[];
          thres=1;
          tstr="";
          );

        if(step==1,
          nsteps=0;
          c=length(savedtrafos);
          draw(p0, color->.9*[1,1,1],size->5);
          p1=mouse();
          drawtext(mouse()-(0,0.05),"Tap anywhere to confirm",color->[1,1,1]);
          if(p0==p1, p1=p0+(0.2,0)); //doppelklick auf die Mitte ändert nichts
          v=p1-p0;
          v=v/|v|;
          p1=p0+0.2*v;
          Tnew=map(p0,p1,p0,p0+(0.2,0));Tnew=Tnew/Tnew_3_3;
          currenttrafos=savedtrafos:>Tnew;
          nrep=[15,5,5]_(c+1);
          minpts=[1,4]_(c+1);

          //Generation of poylnomial relation
          if(polynomGen(p0+(0.2,0),currenttrafos,nrep,thres)!="",tstr=polynomGen(p0+(0.2,0),currenttrafos,nrep,thres),tstr=tstr);

          oldtrafos="";
          forall(1..c,st,oldtrafos=oldtrafos+"t"+text(st)+"="+text(savedtrafos_st)+";");

          // setting A(x) to be the matrix product of the current relation
          parse("matrixA(x):=("+oldtrafos+"t"+text(length(currenttrafos))+"=map(p0,x,p0,p0+(0.2,0));"+tstr+")");
          go=true;

          // Solving by Newton
          nr = re(newton(p1,3));
          // assuring disjoint open sets around snap points
          forall(psnap,ps,
            if(|nr,ps|<.03,go=false);
          );

          // check if newton's result is close enough to zero, and if yes add it to the set of snap
          if(go &|polynomial([nr_1,nr_2,1])_1|<.001&|polynomial([nr_1,nr_2,1])_2|<.001&|(|nr-p0|-0.2)|<0.001,
            psnap=psnap:>nr;
          );
          forall(psnap,ps,
            draw(p0,ps,color->1*[1,1,1],dashtype->3);
            // snapping to snap point 'ps' if 'p1' is element of the open set around 'ps' with an radius of 0.02
            if(|p1-ps|<0.02,
              p1=ps;

            )
          );
          // Interface
          fillcircle(p0,0.2,alpha->0.1,color->.85*[1,1,1]);
          draw(p0,p0+(0.2,0),color->.9*[1,1,1]);
          draw(p0,p1, arrow->true, alpha->.8, size->4, color->[0.9,0.9,0.9]);
          // Preview
          previewtrafo=map(p0,p1,p0,p0+(0.2,0));
          preview=true;
        );
        if(step==2,
          if(|p1,p0+(0.2,0)|>.001,
            pastrot=pastrot :> p0;
            lasttrafo=lasttrafo:>"Rotation";
            Tnew=map(p0,p1,p0,p0+(0.2,0));
            addTrafo(Tnew/Tnew_3_3);
          );
          preview=false;
          colorplot(lb,rb, "layer",[0,0,0,0]);
          step=-1;
        );
      );
      if(mode=="⇹",
        if(step==0,
          p0=mouse();
          if(p0.x<lbpal.x,
            draw(p0, color->.8*[1,1,1],size->5);
            drawtext(p0-(0,0.07),"Tap and drag",color->[1,1,1]);
          );

          psnap=[p0];
          thres=1;//length(orbit);
          pairs=[];
          tstr="";
        );
        if(step==1,
          p1=mouse();
          drawtext(mouse()-(0,0.05),"Tap anywhere to confirm",color->[1,1,1]);
          c=length(savedtrafos);
          mid=0.5*([p0_1,p0_2,1]+[p1_1,p1_2,1]);v=[p1_1,p1_2,1]-[p0_1,p0_2,1];v=[-v_2,v_1];
          Tnew=map(p0,mid,p0+v,p1,mid,[p1_1,p1_2]+v);Tnew=Tnew/Tnew_3_3;
          if(length(pastrefl)==0,nrep=3,nrep=[10,5,3,3,3,3,3,3]_(length(savedtrafos)));
          if(length(pastrefl)==1 & length(pasttrans)==0 & length(pastgtrans)==0 ,
            mid=0.5*(p0+p1);
            v=p1-p0;
            v=[-v.y,v.x];
            l1=perpendicular(p0,join(p0,p1));
            l1=l1/|l1|;
            l2=join(pastrefl_1_2,pastrefl_1_2+pastrefl_1_1);
            l2=l2/|l2|;
            scalarprod=l1*l2;
            if(|scalarprod|>0.95,
              currenttrafos=savedtrafos:>map([.1,.3],[.2,.7]):>Tnew;
              nrep=4;
              ,
              currenttrafos=savedtrafos:>Tnew;
            ),
            currenttrafos=savedtrafos:>Tnew;
          );
          minpts=[1,4]_c;

          //Generation of poylnomial relation
          if(polynomGen(p0,currenttrafos,nrep,thres)!="" & iseven(length(tokenize(polynomGen(p0,currenttrafos,nrep,thres),"*"))),tstr=polynomGen(p0,currenttrafos,nrep,thres),tstr=tstr);

          oldtrafos="";
          forall(1..(c+1),st,oldtrafos=oldtrafos+"t"+text(st)+"="+text(currenttrafos_st)+";");
          // setting A(x) to be the matrix product of the current relation
          parse("matrixA(x):=("+oldtrafos+"mid=0.5*([p0_1,p0_2,1]+x);v=x-[p0_1,p0_2,1];v=[-v_2,v_1];t"+text(length(currenttrafos))+"=map(p0,mid,p0+v,x,mid,[x_1,x_2]+v);"+tstr+")");
          go=true;

          // Solving by Newton
          nr = re(newton(p1,3));

          // assuring disjoint open sets around snap points
          forall(psnap,ps,
            if(|nr,ps|<.04,go=false);
          );
          // check if newton's result is close enough to zero, and if yes add it to the set of snap
          if(go &|polynomial([nr_1,nr_2,1])|<.01 ,
            psnap=psnap:>nr;
          );

          forall(psnap,ps,
            if(|ps-p1|<0.1,
              draw(ps,color->psnapcolor,noborder->true,size->psnapsize);
              // snapping to snap point 'ps' if 'p1' is element of the open set around 'ps' with an radius of 0.04
              if(|p1-ps|<0.04,
                p1=ps;
              )
            );
          );

          if(pastrefl!=[],
            forall(pastrefl,refl,
              linie=join(refl_2,refl_2+refl_1);
              draw(line(linie),color->constructioncolor,dashing->2);
            );
          );
          mid=0.5*(p0+p1);
          v=p1-p0;
          v=[-v.y,v.x];
          draw(p0,color->.8*[1,1,1],size->5);
          draw(p1,color->.8*[1,1,1],size->5);
          draw(mid-v,mid+v,size->2,dashtype->2,alpha->.8, color->constructioncolor);
          previewtrafo=linereflect(join(mid,mid+v));
          preview=true;

        );
        if(step==2,
          preview=false;
          Tnew=linereflect(join(mid,mid+v));
          if(Tnew_3_3!=0,Tnew=Tnew/Tnew_3_3);
          addTrafo(Tnew);
          pastrefl=pastrefl :> [v,mid];
          lasttrafo=lasttrafo:>"Reflection";
          colorplot(lb,rb, "layer",[0,0,0,0]);
          step=-1;
        );
      );
      if(mode=="↴",
        if(step==0,
          p0=mouse();
          if(p0.x<lbpal.x,
            draw(p0, color->.8*[1,1,1],size->5);
            drawtext(mouse()-(0,0.05),"Tap and drag",color->[1,1,1]);
        );
        psnap=[p0];
        psnap2=[p0];
        if(pastrefl!=[],
          forall(pastrefl,pt,
            p01=applyTrafo(linereflect(join(pt_2,pt_2+pt_1)),p0);
            psnap=psnap:>[p01_1,p01_2]/p01_3;;
          )
        );
        thres=1;
        pairs=[];
        tstr="";
        );
        if(step==1,
          draw(p0, color->[0.9,0.9,0.9],size->5);
          p1=mouse();
          drawtext(mouse()-(0,0.05),"Tap to confirm and drag",color->[1,1,1]);
          c=length(savedtrafos);
          mid=0.5*([p0_1,p0_2,1]+[p1_1,p1_2,1]);v=[p1_1,p1_2,1]-[p0_1,p0_2,1];v=[-v_2,v_1];
          if(|v|!=0,vt=0.2*v/|v|,vt=v);
          Tnew=map(p0,mid,p0+v,p1,mid,[p1_1,p1_2]+v)*map(p0+vt,p0);Tnew=Tnew/Tnew_3_3;
          currenttrafos=savedtrafos:>Tnew;
          nrep=5;

          //Generation of poylnomial relation
          if(polynomGen(p0,currenttrafos,nrep,thres)!="",tstr=polynomGen(p0,currenttrafos,nrep,thres),tstr=tstr);

          drawtext(rb+(0.1,0.1),tstr,color->[1,1,1]);
          oldtrafos="";
          forall(1..c,st,oldtrafos=oldtrafos+"t"+text(st)+"="+text(savedtrafos_st)+";");

          // setting A(x) to be the matrix product of the current relation
          parse("matrixA(x):=("+oldtrafos+"mid=0.5*([p0_1,p0_2,1]+x);v=x-[p0_1,p0_2,1];v=[-v_2,v_1];t"+text(length(currenttrafos))+"=map(p0,mid,p0+v,x,mid,[x_1,x_2]+v)*map(p0+vt,p0);"+tstr+")");

          go=true;
          // Solving by Newton
          nr = re(newton(p1,3));

          // assuring disjoint open sets around snap points
          forall(psnap,ps,
            if(|nr,ps|<.04,go=false);
          );

          // check if newton's result is close enough to zero, and if yes add it to the set of snap
          if(go &|polynomial([nr_1,nr_2,1])|<.01,
            psnap=psnap:>nr;
          );

          forall(psnap,ps,
            if(|p1-ps|<.1,
              draw(ps,color->psnapcolor,noborder->true,size->psnapsize);
              // snapping to snap point 'ps' if 'p1' is element of the open set around 'ps' with an radius of 0.04
              if(|p1-ps|<0.04,
                p1=ps;
              )
            );
          );

          if(pastrefl!=[],
            forall(pastrefl,refl,
              linie=join(refl_2,refl_2+refl_1);
              draw(line(linie),color->constructioncolor,dashing->2);
            );
          );
          mid=0.5*(p1+p0);
          v=p1-p0;
          v=[-v.y,v.x];
          p2=p1+0.2*v/|v|;
          draw(p0,color->.8*[1,1,1],size->5);
          draw(p1,color->.8*[1,1,1],size->5);
          draw(p2, color->[0.9,0.9,0.9],size->5);
          draw(p1,p2, arrow->true, alpha->.8, size->4, color->[0.9,0.9,0.9]);
          draw(mid-2*v,mid+2*v,size->2,dashtype->4,alpha->.8, color->constructioncolor);
          previewtrafo1=linereflect(join(mid,mid+v));
          previewtrafo2=map(p0+vt,p0);
          previewtrafo=previewtrafo1*previewtrafo2;
          preview=true;
        );
        if(step==2,
          draw(p0,color->.8*[1,1,1],size->5);
          draw(p1,color->.8*[1,1,1],size->5);
          draw(p2, color->[0.9,0.9,0.9],size->5);
          draw(p1,p2, arrow->true, alpha->.8, size->4, color->constructioncolor);
          draw(mid-2*v,mid+2*v,size->2,dashtype->4,alpha->.8, color->constructioncolor);
          tstr="";
        );
        if(step==3,
          draw(mid-2*v,mid+2*v,size->2,dashtype->4,alpha->.8, color->constructioncolor);
          v=v/|v|;
          w=mouse()-p1;
          w=(w*v)*v;
          p2=p1+w;
          c=length(savedtrafos);
          Tnew=map(p2,p1);Tnew=Tnew/Tnew_3_3;
          //currenttrafos=savedtrafos:>Tnew;
          currenttrafos=pasttrans:>map(p2,p1);
          nrep=7;
          minpts=[1,4]_c;

          //Generation of poylnomial relation
          if(polynomGen(p0,currenttrafos,nrep,thres)!="",tstr=polynomGen(p0,currenttrafos,nrep,thres),tstr=tstr);

          oldtrafos="";
          forall(1..length(pasttrans),st,oldtrafos=oldtrafos+"t"+text(st)+"="+text(pasttrans_st)+";");

          // setting A(x) to be the matrix product of the current relation
          parse("matrixA(x):=("+oldtrafos+"t"+text(length(currenttrafos))+"=map(x,p1);"+tstr+")");

          go=true;

          // Solving by Newton
          nr = re(newton(p2,3));

          // assuring disjoint open sets around snap points
          forall(psnap,ps,
            if(|nr,ps|<.04,go=false);
          );

          // check if newton's result is close enough to zero, and if yes add it to the set of snap
          if(go &|polynomial([nr_1,nr_2,1])|<.001,
            psnap=psnap:>nr;
          );

          forall(psnap,ps,
            if(|p2-ps|<.1,
              draw(ps,color->psnapcolor,noborder->true,size->psnapsize);
              if(|p2-ps|<0.04,
                p2=ps;
              )
            );
          );
          w=p2-p1;
          w=(w*v)*v;
          p2=p1+w;
          draw(p0,color->.8*[1,1,1],size->5);
          draw(p1,color->.8*[1,1,1],size->5);
          draw(p2, color->[0.9,0.9,0.9],size->5);
          draw(p1,p2, arrow->true, alpha->.8, size->4, color->constructioncolor);
          previewtrafo=previewtrafo1*map(p2,p1);
        );
        if(step==4,
          preview=false;
          Tnew=linereflect(join(mid,mid+v))*map(p2,p1);
          if(Tnew_3_3!=0,Tnew=Tnew/Tnew_3_3);
          addTrafo(Tnew);
          pasttrans=pasttrans:>map(p2,p1);
          pastgtrans=pastgtrans:>map(p2,p1);
          pastrefl=pastrefl:>[v,mid];
          lasttrafo=lasttrafo:>"Glide";
          colorplot(lb,rb, "layer",[0,0,0,0]);
          step=-1;
        );
      );

      if(mode=="⎌",
        if(length(savedtrafos)>=1,
           savedtrafos = savedtrafos_(1..(length(savedtrafos)-1));
           colorplot("layer",[0,0,0,0]);
          );
        if(lasttrafo_(-1)=="Translation",pasttrans=pasttrans_(1..(length(pasttrans)-1));lasttrafo=lasttrafo_(1..(length(lasttrafo)-1)));
        if(lasttrafo_(-1)=="Rotation",pastrot=pastrot_(1..(length(pastrot)-1));lasttrafo=lasttrafo_(1..(length(lasttrafo)-1)));
        if(lasttrafo_(-1)=="Reflection",pastrefl=pastrefl_(1..(length(pastrefl)-1));lasttrafo=lasttrafo_(1..(length(lasttrafo)-1)));
        if(lasttrafo_(-1)=="Glide",pastrefl=pastrefl_(1..(length(pastrefl)-1));pasttrans=pasttrans_(1..(length(pasttrans)-1));pastgtrans=pastgtrans_(1..(length(pastgtrans)-1));lasttrafo=lasttrafo_(1..(length(lasttrafo)-1)));
        mode="draw";
        selectf=false;
      );
    </script>


    <script id="csmousedown" type="text/x-cindyscript">
      //wird ausgeführt wenn mouse gedrückt wird

      framecount = 0;
      firstpaint=true;
      playanimation();

    </script>

    <script id="csmousedrag" type="text/x-cindyscript">
      //wird ausgeführt wenn mouse bewegt wird während sie gedrückt ist

      framecount = 0;
      playanimation();

    </script>

    <script id="csmouseup" type="text/x-cindyscript">
      //wird ausgeführt wenn mouse is released
    </script>

    <script id="csmouseclick" type="text/x-cindyscript">
      //wird ausgeführt wenn mouse bewegt wird

      framecount = 0;
      firstpaint=true;
      playanimation();


    </script>

    <script id="cskeydown" type="text/x-cindyscript">
      //wird ausgeführt wenn ein key gedrückt wird
      framecount = 0;
      firstpaint=true;
      playanimation();
      if(keycode()==27,if(mode=="⥅" % mode=="↺"%mode=="⇹"%mode=="↴",previewtrafo=inittrafo;mode="draw"));
    </script>

    <script id="csmultidown" type="text/x-cindyscript">
      framecount = 0;
      firstpaint=true;
      playanimation();
      if(mouse().x>lbpal.x,
        if(|mouse().y-0.8|<16/500,
          tempc=round((mouse().x-lbpal.x)/0.065);
          if(|mouse()-[lbpal.x+tempc*0.065,0.8]|<16/500, selectc=true; selectf=false; ic=tempc;stiftfarbe=farbpalette_ic;mode="draw");
        );
        if(|mouse().y-0.7|<16/500,
          temps=round((mouse().x-lbpal.x)/0.065);
          if(|mouse()-[lbpal.x+temps*0.065,0.7]|<16/500,selects=true;selectf=false;is=temps;stiftstaerke=staerkepalette_is;mode="draw");
        );
        if(|mouse().y-0.5|<40/500,
          temp=round((((mouse().x-lbpal.x)/0.065)-1)/2);
          if(|mouse()-[lbpal.x+(temp*2+1)*0.065,0.5]|<40/500,selectf=true;selectc=false;selects=false;ifu=temp;mode=functions_(ifu+1);step=0)
        );
        if(|mouse()-[lbpal.x+9*0.065,0.5]|<40/500,
          mode="⎌";
          step=0;selectf=false;selectc=false;selects=false;
        );
        if(|mouse()-[lbpal.x+8*0.065,0.2]|<50/500,
          createimage("basis",res,res);
          createimage("canvas",res,res);
          createimage("layer",res,res);
          createimage("output",res,res);
          reset();
        );
        aldelta = 15/255;
        colorplot(lb,rb,"layer",
          imagergba(lb,rb,"layer",#)-[0,0,0,aldelta];
        );
        colorplot(lb,rb,"canvas",
          c0 = imagergba(lb,rb,"canvas",#)-[0,0,0,aldelta];
          if(c0.a>0, c0, [0,0,0,0])
        );
      );
      if(mouse().x<lbpal.x,
        lastmouse=mouse();
        if(mode=="⥅",
          if(savedtrafos!=[],invtrafo=[];currenttrafos=[];forall(savedtrafos,st,invtrafo=invtrafo:>inverse(st));currenttrafos=invtrafo++savedtrafos;
            [orbit,predpoints,predtrafos]=orbit(currenttrafos,p0,1000,3));
        );

      );
    </script>

    <script id="csmultidrag" type="text/x-cindyscript">
      framecount = 0;
      playanimation();
      if(mouse().x<lbpal.x,
        if(firstpaint,lastmouse=mouse();firstpaint=false);
        if(mode=="draw",
          nsteps=8;
          colorplot(lb,rb,"canvas",if(|#-mouse()|<stiftstaerke % distance(lastmouse,mouse(),#)<stiftstaerke,[stiftfarbe_1,stiftfarbe_2,stiftfarbe_3,k],imagergba(lb,rb,"canvas",#)),interpolate->true);
          lastmouse=mouse();
        );
      ,
        if(|mouse().y-0.8|<16/500,
          tempc=round((mouse().x-lbpal.x)/0.065);
          if(|mouse()-[lbpal.x+tempc*0.065,0.8]|<16/500, selectc=true; selectf=false; ic=tempc;stiftfarbe=farbpalette_ic;mode="draw";selectf=false);
        );
        if(|mouse().y-0.7|<16/500,
          temps=round((mouse().x-lbpal.x)/0.065);
          if(|mouse()-[lbpal.x+temps*0.065,0.7]|<16/500,selects=true;selectf=false;is=temps;stiftstaerke=staerkepalette_is;mode="draw";selectf=false);
        );
        if(|mouse().y-0.5|<40/500,
          temp=round((((mouse().x-lbpal.x)/0.065)-1)/2);
          if(|mouse()-[lbpal.x+(temp*2+1)*0.065,0.5]|<40/500,selectf=true;selectc=false;selects=false;ifu=temp;mode=functions_(ifu+1);step=0)
        );
        if(|mouse()-[lbpal.x+9*0.065,0.5]|<40/500,
          mode="⎌";
          step=0;selectf=false;selectc=true;selects=true;
        );
        if(|mouse()-[lbpal.x+8*0.065,0.2]|<50/500,
          createimage("basis",res,res);
          createimage("canvas",res,res);
          createimage("layer",res,res);
          createimage("output",res,res);
          reset();
        );
        aldelta = 15/255;
        colorplot(lb,rb,"layer",
          imagergba(lb,rb,"layer",#)-[0,0,0,aldelta];
        );
        colorplot(lb,rb,"canvas",
          c0 = imagergba(lb,rb,"canvas",#)-[0,0,0,aldelta];
          if(c0.a>0, c0, [0,0,0,0])
        );
      );
    </script>

    <script id="csmultiup" type="text/x-cindyscript">
      if(mouse().x<lbpal.x,
        if(|lastmouse,mouse()|<0.05,istap=true,istap=false);
        if(istap,
          if(step==0,p0=mouse());
          if(mode=="↴"&(step==2),
            if(|mouse(),p1|<.05,step=0;psnap=[p0],if(|mouse(),p2|<.05,step=2;psnap=[p1];thres=1,step=3););
          );
          step=step+1;
        );
      );
    </script>


    <script type="text/javascript">
    CindyJS({
      scripts: "cs*",
      autoplay: true,
      ports: [{
        id: "CSCanvas",
        fill:"window",
        transform: [{
          visibleRect: [-1, 1, 1, -1]
        }]
      }]
    });
    </script>
  </body>
</html>
